// Generated by CoffeeScript 1.4.0
(function() {
  var async,
    __hasProp = {}.hasOwnProperty;

  !(function(name, context, definition) {
    if (typeof require === 'function' && typeof exports === 'object' && typeof module === 'object') {
      return module.exports = definition;
    } else {
      return context[name] = definition;
    }
  })('async', this, async = (function() {
    var key, key2, _fn, _ref;

    async.whilst = function(test, iterator, callback) {
      var _this;
      _this = this;
      return test() ? iterator(function(err){return err ? callback(err) : _this.whilst(test,iterator,callback)}) : callback();
    };

    function async(beginning_result) {
      this.beginning_result = beginning_result != null ? beginning_result : void 0;
      this.a = [];
      this.beginning_length = 0;
      this.processed = 0;
    }

    async.prototype._call = function(result, err) {
      var a;
      if (err) {
        a = this.a[this.a.length - 1];
        this.a = [];
      } else if (this.a.length) {
        a = this.a[0];
      }
      if (typeof a !== 'undefined') {
        return a.call((function() {}), result, err);
      }
    };

    async.prototype._pop = function(parallel, result, err) {
      var current, next,
        _this = this;
      current = this.a.shift();
      next = this.a[0];
      if (this.beforeEach_callback != null) {
        this.beforeEach_callback(result, err);
      }
      return function(result, err) {
        _this.processed++;
        if (err) {
          return _this._call(result, err);
        }
        if (_this.afterEach_callback != null) {
          _this.afterEach_callback(result, err);
        }
        if (!parallel || _this.processed === _this.beginning_length) {
          while (_this._call(result, err) && parallel) {}
        }
      };
    };

    async.prototype._push = function(args, parallel) {
      var dont_end, key, _fn, _ref,
        _this = this;
      if (Object.prototype.toString.call(args[0]) === '[object Function]') {
        args[0] = [args[0]];
        dont_end = true;
      }
      _ref = args[0];
      _fn = function(cb, parallel) {
        _this.beginning_length++;
        return _this.a.push(function(result, err) {
          cb.call(_this._pop(parallel, result, err), result, err);
          if (parallel && 1 !== _this.a.length) {
            _this._call(result, err);
          }
          return parallel;
        });
      };
      for (key in _ref) {
        if (!__hasProp.call(_ref, key)) continue;
        _fn(args[0][key], parallel === null ? !args[0][key].length : parallel);
      }
      if (dont_end == null) {
        this.end(typeof args[1] === 'function' ? args[1] : function() {});
      }
      return this;
    };

    async.prototype.serial = function() {
      return this._push(arguments, false);
    };

    async.prototype.parallel = function() {
      return this._push(arguments, true);
    };

    async.prototype.then = function() {
      return this._push(arguments, null);
    };

    async.prototype.end = function(cb) {
      var _this = this;
      this.a.push(function(result, err) {
        if (_this.afterEach_callback != null) {
          _this.afterEach_callback(result, err);
        }
        if (err && (_this.error_callback != null)) {
          _this.error_callback(err);
        } else if (_this.success_callback != null) {
          _this.success_callback(result);
        }
        return cb.call((function() {}), result, err);
      });
      this._call(this.beginning_result, null);
      return this;
    };

    _fn = function(key) {
      if (typeof async.prototype[key] === 'undefined') {
        async.prototype[key] = function(cb) {
          this[key + '_callback'] = cb;
          return this;
        };
      }
      return async[key] = function() {
        var a;
        return (a = new async)[key].apply(a, arguments);
      };
    };
    for (key in _ref = {
      'begin': ['new', 'try'],
      'beforeAll': ['before'],
      'beforeEach': null,
      'serial': ['series', 'blocking', 'waterfall'],
      'parallel': ['nonblocking'],
      'then': ['do', 'auto'],
      'afterEach': ['between', 'inbetween'],
      'error': ['catch', 'rescue'],
      'success': ['else'],
      'end': ['finally', 'ensure', 'afterAll', 'after', 'complete', 'done']
    }) {
      _fn(key);
      if (_ref[key] != null) {
        for (key2 in _ref[key]) {
          async.prototype[_ref[key][key2]] = async.prototype[key];
          async[_ref[key][key2]] = async[key];
        }
      }
    }

    return async;

  })());

}).call(this);
